/*
 * tools/mkfont.c
 * Pre-render TTF font to C bitmap data for kernel use
 *
 * Build: cc -o mkfont mkfont.c -lm
 * Usage: ./mkfont font.ttf output.c [size]
 */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define STB_TRUETYPE_IMPLEMENTATION
#include "stb_truetype.h"

#define DEFAULT_FONT_SIZE 16
#define FIRST_CHAR 32
#define NUM_CHARS 95 /* 32-126 */

int main(int argc, char **argv) {
  if (argc < 3) {
    fprintf(stderr, "Usage: %s <font.ttf> <output.c> [size]\n", argv[0]);
    return 1;
  }

  const char *ttf_path = argv[1];
  const char *output_path = argv[2];
  int font_size = (argc > 3) ? atoi(argv[3]) : DEFAULT_FONT_SIZE;

  /* Read TTF file */
  FILE *ttf_file = fopen(ttf_path, "rb");
  if (!ttf_file) {
    fprintf(stderr, "Error: Cannot open %s\n", ttf_path);
    return 1;
  }

  fseek(ttf_file, 0, SEEK_END);
  long ttf_size = ftell(ttf_file);
  fseek(ttf_file, 0, SEEK_SET);

  unsigned char *ttf_data = malloc(ttf_size);
  if (!ttf_data) {
    fprintf(stderr, "Error: Cannot allocate memory\n");
    fclose(ttf_file);
    return 1;
  }

  fread(ttf_data, 1, ttf_size, ttf_file);
  fclose(ttf_file);

  /* Initialize font */
  stbtt_fontinfo font;
  if (!stbtt_InitFont(&font, ttf_data,
                      stbtt_GetFontOffsetForIndex(ttf_data, 0))) {
    fprintf(stderr, "Error: Failed to initialize font\n");
    free(ttf_data);
    return 1;
  }

  float scale = stbtt_ScaleForPixelHeight(&font, font_size);

  /* Get font metrics */
  int ascent, descent, line_gap;
  stbtt_GetFontVMetrics(&font, &ascent, &descent, &line_gap);
  ascent = (int)(ascent * scale);
  descent = (int)(descent * scale);

  /* Open output file */
  FILE *out = fopen(output_path, "w");
  if (!out) {
    fprintf(stderr, "Error: Cannot create %s\n", output_path);
    free(ttf_data);
    return 1;
  }

  /* Write header */
  fprintf(out, "/*\n");
  fprintf(out, " * Auto-generated font data from %s\n", ttf_path);
  fprintf(out, " * Font size: %d px\n", font_size);
  fprintf(out, " * Characters: %d-%d (ASCII)\n", FIRST_CHAR,
          FIRST_CHAR + NUM_CHARS - 1);
  fprintf(out, " * Generated by mkfont\n");
  fprintf(out, " */\n");
  fprintf(out, "#include <kernel/types.h>\n\n");

  fprintf(out, "#define FONT_SIZE %d\n", font_size);
  fprintf(out, "#define FONT_FIRST_CHAR %d\n", FIRST_CHAR);
  fprintf(out, "#define FONT_NUM_CHARS %d\n", NUM_CHARS);
  fprintf(out, "#define FONT_ASCENT %d\n", ascent);
  fprintf(out, "#define FONT_DESCENT %d\n", -descent);
  fprintf(out, "\n");

  /* Store glyph info */
  fprintf(out, "struct glyph_info {\n");
  fprintf(out, "    int16_t x0, y0;       /* Bitmap position offset */\n");
  fprintf(out, "    uint8_t width, height; /* Bitmap dimensions */\n");
  fprintf(out, "    int16_t advance;       /* Horizontal advance */\n");
  fprintf(out, "    uint32_t data_offset;  /* Offset into bitmap data */\n");
  fprintf(out, "};\n\n");

  /* Pre-calculate all glyphs */
  struct {
    int x0, y0, x1, y1;
    int width, height;
    int advance, lsb;
    unsigned char *bitmap;
  } glyphs[NUM_CHARS];

  size_t total_bitmap_size = 0;

  for (int i = 0; i < NUM_CHARS; i++) {
    int codepoint = FIRST_CHAR + i;
    int glyph_index = stbtt_FindGlyphIndex(&font, codepoint);

    stbtt_GetGlyphHMetrics(&font, glyph_index, &glyphs[i].advance,
                           &glyphs[i].lsb);
    glyphs[i].advance = (int)(glyphs[i].advance * scale);

    glyphs[i].bitmap =
        stbtt_GetGlyphBitmap(&font, scale, scale, glyph_index, &glyphs[i].width,
                             &glyphs[i].height, &glyphs[i].x0, &glyphs[i].y0);

    if (!glyphs[i].bitmap) {
      glyphs[i].width = 0;
      glyphs[i].height = 0;
    }

    total_bitmap_size += glyphs[i].width * glyphs[i].height;
  }

  /* Write glyph table */
  fprintf(out,
          "static const struct glyph_info font_glyphs[FONT_NUM_CHARS] = {\n");

  uint32_t offset = 0;
  for (int i = 0; i < NUM_CHARS; i++) {
    fprintf(out, "    { %3d, %3d, %3d, %3d, %3d, %5u },  /* '%c' (0x%02X) */\n",
            glyphs[i].x0, glyphs[i].y0, glyphs[i].width, glyphs[i].height,
            glyphs[i].advance, offset,
            (FIRST_CHAR + i >= 32 && FIRST_CHAR + i < 127)
                ? (char)(FIRST_CHAR + i)
                : '?',
            FIRST_CHAR + i);
    offset += glyphs[i].width * glyphs[i].height;
  }

  fprintf(out, "};\n\n");

  /* Write bitmap data */
  fprintf(out, "static const uint8_t font_bitmap[%zu] = {\n",
          total_bitmap_size > 0 ? total_bitmap_size : 1);

  int col = 0;
  for (int i = 0; i < NUM_CHARS; i++) {
    int size = glyphs[i].width * glyphs[i].height;
    if (glyphs[i].bitmap && size > 0) {
      for (int j = 0; j < size; j++) {
        if (col == 0)
          fprintf(out, "    ");
        fprintf(out, "0x%02X,", glyphs[i].bitmap[j]);
        col++;
        if (col >= 16) {
          fprintf(out, "\n");
          col = 0;
        }
      }
      stbtt_FreeBitmap(glyphs[i].bitmap, NULL);
    }
  }

  if (total_bitmap_size == 0) {
    fprintf(out, "    0");
  }

  if (col > 0)
    fprintf(out, "\n");
  fprintf(out, "};\n");

  fclose(out);
  free(ttf_data);

  printf("Generated %s: %d glyphs, %zu bytes bitmap data\n", output_path,
         NUM_CHARS, total_bitmap_size);

  return 0;
}
